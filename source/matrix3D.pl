##_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/
## Prefix Is MAT
##_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/
use strict;


###########################################################
## 行列定義
## [[M11,M12,M13,M14]
##  [M21,M22,M23,M24]
##  [M31,M32,M33,M34]
##  [M41,M42,M43,M44]]
###########################################################

##
## π [原点から見た(-1,0)の角度]
##
sub MAT_PI       () { atan2 0, -1}


##
## 単位行列を生成する。
##
sub MAT_MIdentity {
	return [[1.0, 0.0, 0.0, 0.0],
			[0.0, 1.0, 0.0, 0.0],
			[0.0, 0.0, 1.0, 0.0],
			[0.0, 0.0, 0.0, 1.0]];
}


##
## "左のMatrixから右Matrixへ" の順でエフェクト効果のあるMatrixを返す。
## (Mresult = M1 * M2 * M3 * M4・・・)
##  Mr = M * R の場合は、
## | M00,M01,M02,M03 | | R00,R01,R02,R03 |
## | M10,M11,M12,M13 | | R10,R11,R12,R13 |
## | M20,M21,M22,M23 | | R20,R21,R22,R23 |
## | M30,M31,M32,M33 | | R30,R31,R32,R33 |
## @param パラメータには Matrix のリストを指定する。
##
##
sub MAT_MMultiply {
	my ($m, $m1, $m2);

	$m = shift;
	while(@_){
		$m1 = $m;
		$m2 = shift;
		$m = MAT_MIdentity();

		for my $i(0..3) {
			for my $j(0..3) {
				$m->[$i][$j] =  $m1->[$i][0] * $m2->[0][$j]+
								$m1->[$i][1] * $m2->[1][$j]+
								$m1->[$i][2] * $m2->[2][$j]+
								$m1->[$i][3] * $m2->[3][$j];
			}
		}
	}

	return $m;
}


##
## X軸を中心に angle 回転する行列を作成する。
## @param1 回転角度(ラジアン)
##
sub MAT_MRotationX {
	my ($angle) = @_;

	## 角度の sin と cos を決定する。
	my $sin = sin($angle);
	my $cos = cos($angle);
	my $m = MAT_MIdentity();

	$m->[0][0] = 1.0;	$m->[0][1] =   0.0;	$m->[0][2] =  0.0;	$m->[0][3] = 0.0;
	$m->[1][0] = 0.0;	$m->[1][1] =  $cos;	$m->[1][2] = $sin;	$m->[1][3] = 0.0;
	$m->[2][0] = 0.0;	$m->[2][1] = -$sin;	$m->[2][2] = $cos;	$m->[2][3] = 0.0;
	$m->[3][0] = 0.0;	$m->[3][1] =   0.0;	$m->[3][2] =  0.0;	$m->[3][3] = 1.0;

	return $m;
}


##
## Y軸を中心に angle 回転する行列を作成する。
## @param1 回転角度(ラジアン)
##
sub MAT_MRotationY {
	my ($angle) = @_;

	## 角度の sin と cos を決定する。
	my $sin = sin($angle);
	my $cos = cos($angle);
	my $m = MAT_MIdentity();

	$m->[0][0] = $cos;	$m->[0][1] = 0.0;	$m->[0][2] = -$sin;	$m->[0][3] = 0.0;
	$m->[1][0] =  0.0;	$m->[1][1] = 1.0;	$m->[1][2] =   0.0;	$m->[1][3] = 0.0;
	$m->[2][0] = $sin;	$m->[2][1] = 0.0;	$m->[2][2] =  $cos;	$m->[2][3] = 0.0;
	$m->[3][0] =  0.0;	$m->[3][1] = 0.0;	$m->[3][2] =   0.0;	$m->[3][3] = 1.0;

	return $m;
}


##
## Z軸を中心に angle 回転する行列を作成する。
## @param1 回転角度(ラジアン)
##
sub MAT_MRotationZ {
	my ($angle) = @_;

	## 角度の sin と cos を決定する。
	my $sin = sin($angle);
	my $cos = cos($angle);
	my $m = MAT_MIdentity();

	$m->[0][0] =  $cos;	$m->[0][1] = $sin;	$m->[0][2] = 0.0;	$m->[0][3] = 0.0;
	$m->[1][0] = -$sin;	$m->[1][1] = $cos;	$m->[1][2] = 0.0;	$m->[1][3] = 0.0;
	$m->[2][0] =   0.0;	$m->[2][1] =  0.0;	$m->[2][2] = 1.0;	$m->[2][3] = 0.0;
	$m->[3][0] =   0.0;	$m->[3][1] =  0.0;	$m->[3][2] = 0.0;	$m->[3][3] = 1.0;

	return $m;
}


##
## 任意ベクトル r を軸として angle 回転する行列を作成する。
##
## |    cosT+(1-cosT)Rx2 (1-cosT)RxRy - RzsinT (1-cosT)RzRx+RysinT 0 |
## | (1-cosT)RxRy+RzsinT      cosT+(1-cosT)Ry2 (1-cosT)RyRz-RxsinT 0 |
## | (1-cosT)RzRx+RysinT   (1-cosT)RyRz+RxsinT    cosT+(1-cosT)Rz2 0 |
## |                   0                     0                   0 1 |
##
## @param1 ベクトル
## @param2 回転角度(ラジアン)
##
sub MAT_MRotationAxis {
	my ($r, $angle) = @_;

	## 角度の sin と cos を決定する。
	my $sin   = sin($angle);
	my $cos   = cos($angle);
	my $cos_1 = 1-$cos;
	my $m = MAT_MIdentity();

	$m->[0][0] = $cos_1*$r->[0]**2+$cos;
	$m->[0][1] = $cos_1*$r->[0]*$r->[1] - $r->[2]*$sin;
	$m->[0][2] = $cos_1*$r->[2]*$r->[0] + $r->[1]*$sin;
	$m->[0][3] = 0.0;
	$m->[1][0] = $cos_1*$r->[0]*$r->[1]+$r->[2]*$sin;
	$m->[1][1] = $cos_1*$r->[1]**2+$cos;
	$m->[1][2] = $cos_1*$r->[1]*$r->[2] - $r->[0]*$sin;
	$m->[1][3] = 0.0;
	$m->[2][0] = $cos_1*$r->[2]*$r->[0] + $r->[1]*$sin;
	$m->[2][1] = $cos_1*$r->[1]*$r->[2] + $r->[0]*$sin;
	$m->[2][2] = $cos_1*$r->[2]**2+$cos;
	$m->[2][3] = 0.0;
	$m->[3][0] = 0.0;
	$m->[3][1] = 0.0;
	$m->[3][2] = 0.0;
	$m->[3][3] = 1.0;

	return $m;
}


##
## 平行移動行列を作成する。
## @param1 X軸方向の移動量
## @param2 Y軸方向の移動量
## @param3 Z軸方向の移動量
##
sub MAT_MTranslate {
	my ($dx, $dy, $dz) = @_;

	my $m = MAT_MIdentity();
    $m->[3][0] = $dx; $m->[3][1] = $dy; $m->[3][2] = $dz;

    return $m;
}


##
## スケーリングした行列を作成する。
## @param1 X軸方向のスケーリング係数
## @param2 Y軸方向のスケーリング係数
## @param3 Z軸方向のスケーリング係数
##
sub MAT_MScaling {
	my ($sx, $sy, $sz) = @_;

	my $m = MAT_MIdentity();
    $m->[0][0] = $sx; $m->[1][1] = $sy; $m->[2][2] = $sz;

    return $m;
}


##
## 透視変換行列を作成する。
## @param1 近くのクリップ面までの距離
## @param2 遠くのクリップ面までの距離
## @param3 水平方向の視野角
## @param4 垂直方向の視野角
##
sub MAT_MProjection {
	my ($zNear, $zFar, $fovW, $fovH ) = @_;

	## cot(x) = cos(x)/sin(x)
	my $cotW = cos($fovW*0.5) / sin($fovW*0.5);
	my $cotH = cos($fovH*0.5) / sin($fovH*0.5);
	my $q    = $zFar / ($zFar - $zNear);
	my $m    = MAT_MIdentity();

	$m->[0][0] = $cotW;
	$m->[1][1] = $cotH;
	$m->[2][2] = $q;
	$m->[2][3] = 1.0;
	$m->[3][2] = (-1)*$q*$zNear;
	$m->[3][3] = 0.0;

	return $m;
}


##
## 転置行列を返す。
## @param Matrix
##
sub MAT_MTranspose {
	my ($iM) = @_;
	my $m = MAT_MIdentity();

	$m->[0][0] = $iM->[0][0]; $m->[0][1] = $iM->[1][0]; $m->[0][2] = $iM->[2][0]; $m->[0][3] = $iM->[3][0];
	$m->[1][0] = $iM->[0][1]; $m->[1][1] = $iM->[1][1]; $m->[1][2] = $iM->[2][1]; $m->[1][3] = $iM->[3][1];
	$m->[2][0] = $iM->[0][2]; $m->[2][1] = $iM->[1][2]; $m->[2][2] = $iM->[2][2]; $m->[2][3] = $iM->[3][2];
	$m->[3][0] = $iM->[0][3]; $m->[3][1] = $iM->[1][3]; $m->[3][2] = $iM->[2][3]; $m->[3][3] = $iM->[3][3];

	return $m;
}


##
## 第(i,j)余因子を求める。
## n次の正方行列Ａに対して、その 第p行 第q列 を取り去って得られる行列の行列式に
## -1 の (p+q) 乗を掛けたものを行列Ａの第(p,q)余因子といい、△pq で表す。
## @param1 Matrix
## @param2 行番号(0オリジン)
## @param3 列番号(0オリジン)
##
sub MAT_MYoinshi {
	my ($m, $i, $j) = @_;
	my ($waCnt);

	my $anser = 0;
	my @ar = (0,1,2);
	my $hugo = 1.0;
	for($waCnt=0 ; $waCnt<6 ;$waCnt++){
		if ($waCnt == 3) {
			@ar = (2,1,0);
			$hugo = -1;
		}
		my $ansMul = 1.0;
		for(my $col=0 ; $col<3 ;$col++) {
			my $offsetI = $col      < $i ? 0 : 1;
			my $offsetJ = $ar[$col] < $j ? 0 : 1;
			$ansMul = $ansMul * $m->[$col+$offsetI][$ar[$col]+$offsetJ];
		}
		push(@ar, shift(@ar));
		$anser = $anser + $hugo * $ansMul;
	}

	return $anser*(-1)**($i+$j);
}


##
## 余因子行列を求める。
## @param Matrix
##
sub MAT_MYoinshiMatrix {
	my ($mM) = @_;

	my $yM = MAT_MIdentity();

	for(my $i=0 ; $i<4 ;$i++){
		for(my $j=0 ; $j<4 ;$j++){
			$yM->[$j][$i] = MAT_MYoinshi($mM,$i,$j);
		}
	}

	return $yM;
}


##
## 行列式を返す。
## @param Matrix
##
##
## 3次の行列式は、以下となる。
##        | a b c |
## detA = | p q r | = aqz + brx + cpy - cqx - bpz - ary
##        | x y z |
##
## 余因子の定義
## n次の正方行列Ａに対して、その第ｐ行第ｑ列を取り去って得られる行列の行列式に
## -1 の (p+q) 乗を掛けたものを行列Ａの第(p,q)余因子といい、△pq で表す。
##
## 以下に、４次の行列 M の行列式を返す方法を示す。
## | M00,M01,M02,M03 |
## | M10,M11,M12,M13 |
## | M20,M21,M22,M23 |
## | M30,M31,M32,M33 |
##
## まず、上記の行列に関してΔ11、Δ12、Δ21、Δ22 の各余因子を求める。
## Δ11 =       M11*M22*M33 + M12*M23*M31 + M13*M21*M32 - M13*M22*M31 - M12*M21*M33 - M11*M23*M32
## Δ12 = (-1)*(M10*M22*M33 + M12*M23*M30 + M13*M20*M32 - M13*M22*M30 - M12*M20*M33 - M10*M23*M32)
## Δ21 = (-1)*(M01*M22*M33 + M02*M23*M31 + M03*M21*M32 - M03*M22*M31 - M02*M21*M33 - M01*M23*M32)
## Δ22 =       M00*M22*M33 + M02*M23*M30 + M03*M20*M32 - M03*M22*M30 - M02*M20*M33 - M00*M23*M32
##
## よって、ヤコビの定理から以下となる。
## detM = (Δ11*Δ22 - Δ12*Δ21) / (M22*M33 - M23*M32)
##
sub MAT_MDeterminant {
	my ($mM) = @_;

	my $d11 = $mM->[1][1]*$mM->[2][2]*$mM->[3][3] +
			  $mM->[1][2]*$mM->[2][3]*$mM->[3][1] +
			  $mM->[1][3]*$mM->[2][1]*$mM->[3][2] -
			  $mM->[1][3]*$mM->[2][2]*$mM->[3][1] -
			  $mM->[1][2]*$mM->[2][1]*$mM->[3][3] -
			  $mM->[1][1]*$mM->[2][3]*$mM->[3][2];
	my $d12 = (-1) *
			 ($mM->[1][0]*$mM->[2][2]*$mM->[3][3] +
			  $mM->[1][2]*$mM->[2][3]*$mM->[3][0] +
			  $mM->[1][3]*$mM->[2][0]*$mM->[3][2] -
			  $mM->[1][3]*$mM->[2][2]*$mM->[3][0] -
			  $mM->[1][2]*$mM->[2][0]*$mM->[3][3] -
			  $mM->[1][0]*$mM->[2][3]*$mM->[3][2] );
	my $d21 = (-1) *
			 ($mM->[0][1]*$mM->[2][2]*$mM->[3][3] +
			  $mM->[0][2]*$mM->[2][3]*$mM->[3][1] +
			  $mM->[0][3]*$mM->[2][1]*$mM->[3][2] -
			  $mM->[0][3]*$mM->[2][2]*$mM->[3][1] -
			  $mM->[0][2]*$mM->[2][1]*$mM->[3][3] -
			  $mM->[0][1]*$mM->[2][3]*$mM->[3][2] );

	my $d22 = $mM->[0][0]*$mM->[2][2]*$mM->[3][3] +
			  $mM->[0][2]*$mM->[2][3]*$mM->[3][0] +
			  $mM->[0][3]*$mM->[2][0]*$mM->[3][2] -
			  $mM->[0][3]*$mM->[2][2]*$mM->[3][0] -
			  $mM->[0][2]*$mM->[2][0]*$mM->[3][3] -
			  $mM->[0][0]*$mM->[2][3]*$mM->[3][2];

	return ($d11*$d22 - $d12*$d21) / ($mM->[2][2]*$mM->[3][3] - $mM->[2][3]*$mM->[3][2]);
}


##
## 逆行列を求める。
## 但し、行列が正則行列でない場合(|A|==0)は逆行列が存在しない。
## その場合は0を返す
## @param Matrix
##
sub MAT_MInverse {
	my ($m) = @_;

	## 行列式を求める
	my $det = MAT_MDeterminant($m);
	return 0 if ($det == 0);

	## 余因子行列を求める
	my $yoi = MAT_MYoinshiMatrix($m);

	## 余因子行列の各要素を 1/$det 倍する
	for(my $i=0 ; $i<4 ;$i++){
		for(my $j=0 ; $j<4 ;$j++){
			$yoi->[$i][$j] *= (1/$det);
		}
	}

	return $yoi;
}


##
## 度をラジアンに変換する
##
sub MAT_DegToRad {
	my $deg = shift;
	return ( MAT_PI * $deg) / 180;
}


##
## Matrix を標準出力に出力する
## @param Matrix
##
sub MAT_MPrint {
	my $m = shift;
	print $m->[0][0].' '.$m->[0][1].' '.$m->[0][2].' '.$m->[0][3] , "\n";
	print $m->[1][0].' '.$m->[1][1].' '.$m->[1][2].' '.$m->[1][3] , "\n";
	print $m->[2][0].' '.$m->[2][1].' '.$m->[2][2].' '.$m->[2][3] , "\n";
	print $m->[3][0].' '.$m->[3][1].' '.$m->[3][2].' '.$m->[3][3] , "\n";
}

1;
